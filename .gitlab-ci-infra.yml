initial_deploy_infrastructure:
  stage: initial_deploy
  image:
    name: hashicorp/terraform:light
    entrypoint: [""]
  rules:
    - when: manual
  script:
    # Check for the marker file in the cache directory
    - if [ -f infra/.marker ]; then echo "Marker exists; skipping deployment"; exit 0; fi
    - cd infra
    - terraform init
    - terraform apply -auto-approve
    - terraform output -raw lb_dns > lb_dns.txt
    - terraform output -raw autoscaling_group_name > autoscaling_group_name.txt
  when: manual # run manually when needed.
  cache:
    key: terraform-cache
    policy: push
    paths:
      - infra/terraform.tfstate
      - infra/autoscaling_group_name.txt
      - infra/.marker
  artifacts:
    when: always
    paths:
      - infra/terraform.tfstate
      - infra/lb_dns.txt
      - infra/autoscaling_group_name.txt



insert_data:
  stage: seed_data
  image: alpine:latest
  dependencies:
    - initial_deploy_infrastructure
  before_script:
    - apk add --no-cache bash curl
    - chmod +x seed-application/add_data.sh
  script:
    - export DNS=$(cat infra/lb_dns.txt | tr -d '\n')
    - export GOALS_ENDPOINT="http://${DNS}/api/goals"
    - echo "Using GOALS_ENDPOINT=$GOALS_ENDPOINT"
    - ./seed-application/add_data.sh seed-application/data.md
  when: manual


destroy_infrastructure:
  stage: destroy_infrastructure
  image:
    name: hashicorp/terraform:light
    entrypoint: [""]
  dependencies:
    - initial_deploy_infrastructure
  cache:
    key: terraform-cache
    paths:
      - infra/terraform.tfstate
  script:
    - cd infra
    - terraform init
    - terraform destroy -auto-approve
  when: manual
